//:: rocker_p4_prefix = "rocker_" + p4_prefix + "_"
/*
Copyright 2013-present Barefoot Networks, Inc. 

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
/*
 *
 * DO NOT EDIT:  This file is automatically generated.
 *
 */

#include "rocker_p4.h"
#include "${rocker_p4_prefix}enums.h"
#include "${rocker_p4_prefix}tables.h"
#include "${rocker_p4_prefix}pd.h"

#define PD_DEBUG 1

#define HOST_BYTE_ORDER_CALLER 1

#define BYTE_ROUND_UP(x) ((x + 7) >> 3)

//::
//:: def get_type(byte_width):
//::   if byte_width == 1:
//::     return "unsigned char"
//::   elif byte_width == 2:
//::     return "unsigned short"
//::   elif byte_width <= 4:
//::     return "unsigned int"
//::   else:
//::     return "unsigned char *"
//::   #endif
//:: #enddef
//::
//:: def get_num_match_bits(match_fields, field_info):
//::   num_bits = 0
//::   for field, type in match_fields:
//::     if type == "valid": continue
//::     f_info = field_info[field]
//::     num_bits += f_info["bit_width"]
//::   #endfor
//::   return num_bits
//:: #enddef
//::
//::
//:: # match_fields is list of tuples (name, type)
//:: def gen_match_params(match_fields, field_info):
//::   params = []
//::   for field, type in match_fields:
//::     if type == "valid":
//::       params += [(field + "_valid", 1)]
//::       continue
//::     #endif
//::     f_info = field_info[field]
//::     bytes_needed = (f_info["bit_width"] + 7 ) / 8
//::     params += [(field, bytes_needed)]
//::     if type == "lpm": params += [(field + "_prefix_length", 2)]
//::     if type == "ternary": params += [(field + "_mask", bytes_needed)]
//::   #endfor
//::   return params
//:: #enddef
//::
//:: def gen_action_params(names, byte_widths):
//::   params = []
//::   for name, width in zip(names, byte_widths):
//::     name = "action_" + name
//::     params += [(name, width)]
//::   #endfor
//::   return params
//:: #enddef
//::
//::

//:: for table, t_info in table_info.items():
//::   if not t_info["match_fields"]: continue
static inline void ${rocker_p4_prefix}build_key_${table}
(
 unsigned char *key,
 ${rocker_p4_prefix}${table}_match_spec_t *match_spec
)
{
#ifdef HOST_BYTE_ORDER_CALLER
  unsigned int tmp32;
  (void) tmp32;
#endif

//::   for field_name, field_match_type in t_info["reordered_match_fields"]:
//::     if field_match_type == "valid":
  *(key++) = (match_spec->${field_name}_valid > 0);

//::       continue
//::     #endif
//::     f_info = field_info[field_name]
//::     width = (f_info["bit_width"] + 7 ) / 8
//::     if width > 4:
  memcpy(key, match_spec->${field_name}, ${width});
  key += ${width};
//::     else:
#ifdef HOST_BYTE_ORDER_CALLER
  tmp32 = match_spec->${field_name};
  tmp32 = htonl(tmp32);
  *(unsigned int *) key = tmp32;
#else
  *(unsigned int *) key = match_spec->${field_name};
#endif
  key += sizeof(unsigned int);
//::     #endif
  
//::   #endfor
}

//:: #endfor
//::
//::
//:: for table, t_info in table_info.items():
//::   if not t_info["match_fields"]: continue
//::   match_type = t_info["match_type"]
//::   if match_type != "ternary" and match_type != "lpm": continue
/*static inline*/ void ${rocker_p4_prefix}build_mask_${table}
(
 unsigned char *mask,
 ${rocker_p4_prefix}${table}_match_spec_t *match_spec
)
{
#ifdef HOST_BYTE_ORDER_CALLER
  unsigned int tmp32;
  unsigned short tmp16;
  (void) tmp32;
  (void) tmp16;
#endif
  int bits_to_reset; /* for lpm mask */
  (void) bits_to_reset; /* compiler */

//::   for field_name, field_match_type in t_info["reordered_match_fields"]:
//::
//::     if field_match_type == "valid":
//::       # already set to 1s
  mask++;
//::       continue
//::     #endif
//::
//::     f_info = field_info[field_name]
//::     width = (f_info["bit_width"] + 7 ) / 8
//::     field_width = max(4, width)
//::     bit_width = f_info["bit_width"]
//::
//::     if field_match_type == "exact":
//::       # already set to 1s
  mask += ${field_width};
//::
//::     elif field_match_type == "ternary":
//::       if width > 4:
  memcpy(mask, match_spec->${field_name}_mask, ${width});
  mask += ${width};
//::       else:
#ifdef HOST_BYTE_ORDER_CALLER
  tmp32 = match_spec->${field_name}_mask;
  tmp32 = htonl(tmp32);
  *(unsigned int *) mask = tmp32;
#else
  *(unsigned int *) mask = match_spec->${field_name}_mask;
#endif
  mask += sizeof(unsigned int);
//::       #endif
//::
//::     elif field_match_type == "lpm":
  bits_to_reset = ${bit_width} - match_spec->${field_name}_prefix_length;
  if (bits_to_reset >= 8) {
    memset(mask + ${width} - bits_to_reset / 8, 0, bits_to_reset / 8);
  }
  if (bits_to_reset % 8 != 0) {
    mask[${width} - 1 - bits_to_reset / 8] = (unsigned char) 0xFF << (bits_to_reset % 8);
  }
  mask += ${field_width};
//::     #endif

//::   #endfor
}

//:: #endfor

//:: for action, a_info in action_info.items():
//::   if not a_info["param_names"]: continue
//::   action_params = gen_action_params(a_info["param_names"],
//::                                     a_info["param_byte_widths"])
static inline void ${rocker_p4_prefix}build_action_spec_${action}
(
 unsigned char *data,
 ${rocker_p4_prefix}${action}_action_spec_t *action_spec
)
{
#ifdef HOST_BYTE_ORDER_CALLER
  unsigned short tmp16;
  unsigned int tmp32;
  (void) tmp16;
  (void) tmp32;
#endif
//::
//::   for idx, param in enumerate(action_params):

//::     name, width = param
//::     if width > 4:
  memcpy(data, action_spec->${name}, ${width});
  data += ${width};
//::     else:
#ifdef HOST_BYTE_ORDER_CALLER
  tmp32 = action_spec->${name};
  tmp32 = htonl(tmp32);
  *(unsigned int *) data = tmp32;
#else
  *(unsigned int *) data = action_spec->${name};
#endif
  data += sizeof(unsigned int);
//::     #endif

//::   #endfor

}

//:: #endfor

/* ADD ENTRIES */

//:: for table, t_info in table_info.items():
//::   act_prof = t_info["action_profile"]
//::   if act_prof is not None: continue
//::   match_type = t_info["match_type"]
//::   has_match_spec = len(t_info["match_fields"]) > 0
//::   for action in t_info["actions"]:
//::     a_info = action_info[action]
//::     has_action_spec = len(a_info["param_names"]) > 0
//::     params = []
//::     if has_match_spec:
//::       params += [rocker_p4_prefix + table + "_match_spec_t *match_spec"]
//::     #endif
//::     if match_type == "ternary":
//::       params += ["int priority"]
//::     #endif
//::     if has_action_spec:
//::       params += [rocker_p4_prefix + action + "_action_spec_t *action_spec"]
//::     #endif
//::     if t_info["support_timeout"]:
//::       params += ["unsigned int ttl"]
//::     #endif
//::     params += [rocker_p4_prefix + table + "_entry_t *entry"]
//::     params += ["rocker_p4_entry_hdl_t *entry_hdl"]
//::     param_str = ",\n ".join(params)
//::     name = rocker_p4_prefix + table + "_table_entry_create_with_" + action
/**
 * @brief ${name}
 * @param sess_hdl
 * @param dev_tgt
//::     if has_match_spec:
 * @param match_spec
//::     #endif
//::     if match_type == "ternary":
 * @param priority
//::     #endif
//::     if has_action_spec:
 * @param action_spec
//::     #endif
 * @param entry_hdl
*/
rocker_p4_status_t
${name}
(
 ${param_str}
)
{

//:: if t_info["support_timeout"] is True:
  entry->ttl.tv_sec = ttl;
  entry->ttl.tv_usec = 0;
//:: #endif

//::     action_idx = t_info["actions_idx"][action]
  entry->action_id = ${action_idx};

//::     if has_match_spec:
  ${rocker_p4_prefix}build_key_${table}(entry->key, match_spec);
//::     #endif

//::     if match_type == "ternary":
  /* we start by setting the mask entirely to 1s */
  memset(entry->mask, 0xFF, sizeof(entry->mask));
  ${rocker_p4_prefix}build_mask_${table}(entry->mask, match_spec);
//::     #endif

//::     if match_type == "lpm":
//::       lpm_field_name, _ = t_info["reordered_match_fields"][-1]
//::       f_info = field_info[lpm_field_name]
//::       width = (f_info["bit_width"] + 7) / 8
  entry->prefix_width = match_spec->${lpm_field_name}_prefix_length;
//::       # for container alignment
//::       if width <= 4:
  entry->prefix_width += 8 * sizeof(unsigned int) - ${f_info["bit_width"]};
//::       #endif
//::       exact_fields_width = 0 # will include valid matches
//::       for field_name, _ in t_info["reordered_match_fields"][:-1]:
//::         f_info = field_info[field_name]
//::         width = (f_info["bit_width"] + 7) / 8
//::         exact_fields_width += 8 * max(width, 4)
//::       #endfor
  entry->prefix_width += ${exact_fields_width};
//::     elif match_type == "ternary":
  entry->priority = priority;
//::     #endif

//::     if has_action_spec:
  ${rocker_p4_prefix}build_action_spec_${action}(entry->action_data, action_spec);
//::     #endif

  *entry_hdl = 0;
  return 0;
}

//::   #endfor
//:: #endfor

/* SET DEFAULT_ACTION */

//:: for table, t_info in table_info.items():
//::   act_prof = t_info["action_profile"]
//::   if act_prof is not None: continue
//::   for action in t_info["actions"]:
//::     name = rocker_p4_prefix + table + "_set_default_action_" + action
//::     a_info = action_info[action]
//::     has_action_spec = len(a_info["param_names"]) > 0
//::     params = ["void"]
//::     if has_action_spec:
//::       params = [rocker_p4_prefix + action + "_action_spec_t *action_spec"]
//::     #endif
//::     param_str = ",\n ".join(params)
/**
 * @brief ${name}
//::     if has_action_spec:
 * @param action_spec
//::     #endif
*/
unsigned int
${name}
(
 ${param_str}
)
{
//::     if has_action_spec:
//::        action_data_width = t_info["action_data_byte_width"]
  unsigned char _data[${action_data_width}];
  ${rocker_p4_prefix}build_action_spec_${action}(_data, action_spec);
//::     #endif

//::     action_idx = t_info["actions_idx"][action]
  return ${action_idx};
}

//::   #endfor
//:: #endfor


/* INDIRECT ACTION DATA AND MATCH SELECT */

//:: for table, t_info in table_info.items():
//::   act_prof = t_info["action_profile"]
//::   if act_prof is None: continue
//::   act_prof_info = action_profiles[act_prof]
//::   has_selector = act_prof_info["selection_key"] is not None
//::   for action in t_info["actions"]:
//::     a_info = action_info[action]
//::     has_action_spec = len(a_info["param_names"]) > 0
//::     params = []
//::     if has_action_spec:
//::       params += [rocker_p4_prefix + action + "_action_spec_t *action_spec"]
//::     #endif
//::     params += ["rocker_p4_mbr_hdl_t *mbr_hdl"]
//::     param_str = ",\n ".join(params)
//::     name = rocker_p4_prefix + act_prof + "_add_member_with_" + action
rocker_p4_status_t
${name}
(
 ${param_str}
)
{
//::     action_data_width = act_prof_info["action_data_byte_width"]
  char _data[${action_data_width}];

//::     if has_action_spec:
  build_action_spec_${action}((unsigned char *) _data, action_spec);
//::     #endif

  *mbr_hdl = ${rocker_p4_prefix}action_profiles_add_entry_${act_prof}(_data);

  rocker_p4_ms_new_mbr(&ms_${act_prof}_state, 0, *mbr_hdl);
  rocker_p4_ms_set_mbr_act(&ms_${act_prof}_state, 0,
		    *mbr_hdl, action_${action});
  
  return 0;
}

//::     params = []
//::     if has_action_spec:
//::       params += [rocker_p4_prefix + action + "_action_spec_t *action_spec"]
//::     #endif
//::     param_str = ",\n ".join(params)
//::     name = rocker_p4_prefix + act_prof + "_modify_member_with_" + action
rocker_p4_status_t
${name}
(
 ${param_str}
)
{
  rocker_p4_act_hdl_t act_hdl = rocker_p4_ms_get_mbr_act(&ms_${act_prof}_state, dev_id, mbr_hdl);
  // this target only supports modify with same action
  if(act_hdl != action_${action}) return -1;

//::     action_data_width = act_prof_info["action_data_byte_width"]
//::     if has_action_spec:
  char _data[${action_data_width}];
  ${rocker_p4_prefix}build_action_spec_${action}((unsigned char *) _data, action_spec);
  return action_profiles_modify_entry_${act_prof}(mbr_hdl, _data);
//::     else:
  return 0;
//::     #endif
}

//::   #endfor
//::
//::   if has_selector:
void grp_del_mbr_fn_${act_prof}
(
 unsigned char dev_id,
 rocker_p4_mbr_hdl_t mbr_hdl,
 rocker_p4_grp_hdl_t grp_hdl,
 void *aux
)
{
  action_profiles_delete_member_from_group(RMT_ACT_PROF_${act_prof},
					   grp_hdl,
					   mbr_hdl);
}

//::   #endif
//::
//::   params = ["rocker_p4_sess_hdl_t sess_hdl",
//::             "unsigned char dev_id",
//::             "rocker_p4_mbr_hdl_t mbr_hdl"]
//::   param_str = ",\n ".join(params)
//::   name = rocker_p4_prefix + act_prof + "_del_member"
rocker_p4_status_t
${name}
(
 ${param_str}
)
{
//::   if has_selector:
  /* check group membership */
  rocker_p4_ms_mbr_apply_to_grps(&ms_${act_prof}_state, 0, mbr_hdl,
			  grp_del_mbr_fn_${act_prof}, NULL);
//::   #endif
  rocker_p4_status_t status = action_profiles_delete_entry_${act_prof}(mbr_hdl);
  rocker_p4_ms_del_mbr(&ms_${act_prof}_state, 0, mbr_hdl);
  return status;
}

//::   if not has_selector: continue
//::   params = ["rocker_p4_sess_hdl_t sess_hdl",
//::             "rocker_p4_dev_target_t dev_tgt",
//::             "unsigned short max_grp_size",
//::             "rocker_p4_grp_hdl_t *grp_hdl"]
//::   param_str = ",\n ".join(params)
//::   name = rocker_p4_prefix + act_prof + "_create_group"
rocker_p4_status_t
${name}
(
 ${param_str}
)
{
  *grp_hdl = action_profiles_create_group(RMT_ACT_PROF_${act_prof});
  return 0;
}

//::   params = ["rocker_p4_sess_hdl_t sess_hdl",
//::             "unsigned char dev_id",
//::             "rocker_p4_grp_hdl_t grp_hdl"]
//::   param_str = ",\n ".join(params)
//::   name = rocker_p4_prefix + act_prof + "_del_group"
rocker_p4_status_t
${name}
(
 ${param_str}
)
{
  return action_profiles_delete_group(RMT_ACT_PROF_${act_prof}, grp_hdl);
}

//::   params = ["rocker_p4_sess_hdl_t sess_hdl",
//::             "unsigned char dev_id",
//::             "rocker_p4_grp_hdl_t grp_hdl",
//::             "rocker_p4_mbr_hdl_t mbr_hdl"]
//::   param_str = ",\n ".join(params)
//::   name = rocker_p4_prefix + act_prof + "_add_member_to_group"
rocker_p4_status_t
${name}
(
 ${param_str}
)
{
  rocker_p4_act_hdl_t act_hdl = rocker_p4_ms_get_mbr_act(&ms_${act_prof}_state, dev_id, mbr_hdl);
  rocker_p4_status_t status = action_profiles_add_member_to_group(RMT_ACT_PROF_${act_prof},
							      grp_hdl,
							      mbr_hdl);
  rocker_p4_ms_add_mbr_to_grp(&ms_${act_prof}_state, 0, mbr_hdl, grp_hdl);
  rocker_p4_ms_set_grp_act(&ms_${act_prof}_state, 0, grp_hdl, act_hdl);
  return status;
}

//::   params = ["rocker_p4_sess_hdl_t sess_hdl",
//::             "unsigned char dev_id",
//::             "rocker_p4_grp_hdl_t grp_hdl",
//::             "rocker_p4_mbr_hdl_t mbr_hdl"]
//::   param_str = ",\n ".join(params)
//::   name = rocker_p4_prefix + act_prof + "_del_member_from_group"
rocker_p4_status_t
${name}
(
 ${param_str}
)
{
  rocker_p4_status_t status = action_profiles_delete_member_from_group(RMT_ACT_PROF_${act_prof},
								grp_hdl,
								mbr_hdl);
  rocker_p4_ms_del_mbr_from_grp(&ms_${act_prof}_state, 0, mbr_hdl, grp_hdl);
  return status;
}

//::   params = ["rocker_p4_sess_hdl_t sess_hdl",
//::             "unsigned char dev_id",
//::             "rocker_p4_grp_hdl_t grp_hdl",
//::             "rocker_p4_mbr_hdl_t mbr_hdl"]
//::   param_str = ",\n ".join(params)
//::   name = rocker_p4_prefix + act_prof + "_deactivate_group_member"
rocker_p4_status_t
${name}
(
 ${param_str}
)
{
  return ${rocker_p4_prefix + act_prof}_del_member_from_group(sess_hdl, dev_id,
						       grp_hdl, mbr_hdl);
}

//::   params = ["rocker_p4_sess_hdl_t sess_hdl",
//::             "unsigned char dev_id",
//::             "rocker_p4_grp_hdl_t grp_hdl",
//::             "rocker_p4_mbr_hdl_t mbr_hdl"]
//::   param_str = ",\n ".join(params)
//::   name = rocker_p4_prefix + act_prof + "_reactivate_group_member"
rocker_p4_status_t
${name}
(
 ${param_str}
)
{
  return ${rocker_p4_prefix + act_prof}_add_member_to_group(sess_hdl, dev_id,
						     grp_hdl, mbr_hdl);
}

//:: #endfor


//:: for table, t_info in table_info.items():
//::   act_prof = t_info["action_profile"]
//::   if act_prof is None: continue
//::   has_selector = action_profiles[act_prof]["selection_key"] is not None
//::   match_type = t_info["match_type"]
//::   has_match_spec = len(t_info["match_fields"]) > 0
//::   params = ["rocker_p4_sess_hdl_t sess_hdl",
//::             "rocker_p4_dev_target_t dev_tgt"]
//::   if has_match_spec:
//::     params += [rocker_p4_prefix + table + "_match_spec_t *match_spec"]
//::   #endif
//::   if match_type == "ternary":
//::     params += ["int priority"]
//::   #endif
//::   params_wo = params + ["rocker_p4_mbr_hdl_t mbr_hdl", "rocker_p4_entry_hdl_t *entry_hdl"]
//::   param_str = ",\n ".join(params_wo)
//::   name = rocker_p4_prefix + table + "_add_entry"
rocker_p4_status_t
${name}
(
 ${param_str}
)
{
  ${rocker_p4_prefix}${table}_entry_t entry;

//:: if t_info["support_timeout"] is True:
  entry.ttl.tv_sec = ttl;
  entry.ttl.tv_usec = 0;
//:: #endif

  rocker_p4_act_hdl_t act_hdl = rocker_p4_ms_get_mbr_act(&ms_${act_prof}_state,
					   0, mbr_hdl);
  entry.action_id = tables_get_action_id(RMT_TABLE_${table}, act_hdl);

//::     if has_match_spec:
  build_key_${table}(entry.key, match_spec);
//::     #endif

//::     if match_type == "ternary":
  /* we start by setting the mask entirely to 1s */
  memset(entry.mask, 0xFF, sizeof(entry.mask));
  build_mask_${table}(entry.mask, match_spec);
//::     #endif

//::     if match_type == "lpm":
//::       lpm_field_name, _ = t_info["reordered_match_fields"][-1]
//::       f_info = field_info[lpm_field_name]
//::       width = (f_info["bit_width"] + 7) / 8
  entry.prefix_width = match_spec->${lpm_field_name}_prefix_length;
//::       # for container alignment
//::       if width <= 4:
  entry.prefix_width += 8 * sizeof(unsigned int) - ${f_info["bit_width"]};
//::       #endif
//::       exact_fields_width = 0 # will include valid matches
//::       for field_name, _ in t_info["reordered_match_fields"][:-1]:
//::         f_info = field_info[field_name]
//::         width = (f_info["bit_width"] + 7) / 8
//::         exact_fields_width += 8 * max(width, 4)
//::       #endfor
  entry.prefix_width += ${exact_fields_width};
//::     elif match_type == "ternary":
  entry.priority = priority;
//::     #endif

  *(unsigned int *) entry.action_data = mbr_hdl;
  assert(mbr_hdl >> 24 == 0);

  int rv = tables_add_entry_${table}(&entry);
  *entry_hdl = rv;
  return (rv < 0);
}

//::   if not has_selector: continue
//::   params_w = params + ["rocker_p4_grp_hdl_t grp_hdl", "rocker_p4_entry_hdl_t *entry_hdl"]
//::   param_str = ",\n ".join(params_w)
//::   name = rocker_p4_prefix + table + "_add_entry_with_selector"
rocker_p4_status_t
${name}
(
 ${param_str}
)
{
  ${rocker_p4_prefix}${table}_entry_t entry;

//:: if t_info["support_timeout"] is True:
  entry.ttl.tv_sec = ttl;
  entry.ttl.tv_usec = 0;
//:: #endif

  rocker_p4_act_hdl_t act_hdl = rocker_p4_ms_get_grp_act(&ms_${act_prof}_state,
					   0, grp_hdl);
  entry.action_id = tables_get_action_id(RMT_TABLE_${table}, act_hdl);

//::     if has_match_spec:
  build_key_${table}(entry.key, match_spec);
//::     #endif

//::     if match_type == "ternary":
  /* we start by setting the mask entirely to 1s */
  memset(entry.mask, 0xFF, sizeof(entry.mask));
  build_mask_${table}(entry.mask, match_spec);
//::     #endif

//::     if match_type == "lpm":
//::       lpm_field_name, _ = t_info["reordered_match_fields"][-1]
//::       f_info = field_info[lpm_field_name]
//::       width = (f_info["bit_width"] + 7) / 8
  entry.prefix_width = match_spec->${lpm_field_name}_prefix_length;
//::       # for container alignment
//::       if width <= 4:
  entry.prefix_width += 8 * sizeof(unsigned int) - ${f_info["bit_width"]};
//::       #endif
//::       exact_fields_width = 0 # will include valid matches
//::       for field_name, _ in t_info["reordered_match_fields"][:-1]:
//::         f_info = field_info[field_name]
//::         width = (f_info["bit_width"] + 7) / 8
//::         exact_fields_width += 8 * max(width, 4)
//::       #endfor
  entry.prefix_width += ${exact_fields_width};
//::     elif match_type == "ternary":
  entry.priority = priority;
//::     #endif

  *(unsigned int *) entry.action_data = grp_hdl;
  assert(grp_hdl >> 24 == 0);
  entry.action_data[3] = 0x80;

  int rv = tables_add_entry_${table}(&entry);
  *entry_hdl = rv;
  return (rv < 0);
}

//:: #endfor

//:: for table, t_info in table_info.items():
//::   act_prof = t_info["action_profile"]
//::   if act_prof is None: continue
//::   has_selector = action_profiles[act_prof]["selection_key"] is not None
//::   params = ["rocker_p4_sess_hdl_t sess_hdl",
//::             "rocker_p4_dev_target_t dev_tgt"]
//::   params_wo = params + ["rocker_p4_mbr_hdl_t mbr_hdl", "rocker_p4_entry_hdl_t *entry_hdl"]
//::   param_str = ",\n ".join(params_wo)
//::   name = rocker_p4_prefix + table + "_set_default_entry"
rocker_p4_status_t
${name}
(
 ${param_str}
)
{
  rocker_p4_act_hdl_t act_hdl = rocker_p4_ms_get_mbr_act(&ms_${act_prof}_state,
					   0, mbr_hdl);
  int action_id = tables_get_action_id(RMT_TABLE_${table}, act_hdl);

  assert(mbr_hdl >> 24 == 0);
  unsigned int _data = mbr_hdl;

  *entry_hdl = tables_set_default_${table}(action_id, (unsigned char *) &_data);
  return 0;
}

//::   if not has_selector: continue
//::   params_w = params + ["rocker_p4_grp_hdl_t grp_hdl", "rocker_p4_entry_hdl_t *entry_hdl"]
//::   param_str = ",\n ".join(params_w)
//::   name = rocker_p4_prefix + table + "_set_default_entry_with_selector"
rocker_p4_status_t
${name}
(
 ${param_str}
)
{
  rocker_p4_act_hdl_t act_hdl = rocker_p4_ms_get_grp_act(&ms_${act_prof}_state,
					   0, grp_hdl);
  int action_id = tables_get_action_id(RMT_TABLE_${table}, act_hdl);

  assert(grp_hdl >> 24 == 0);
  unsigned int _data = grp_hdl & 0x80;

  *entry_hdl = tables_set_default_${table}(action_id, (unsigned char *) &_data);
  return 0;
}

//:: #endfor
